#!/usr/bin/env ruby

require 'json'

class EchoServer

  def initialize
    @node_id = nil
    @next_msg_id = 0
  end

  def main!
    while line = STDIN.gets
      req = JSON.parse(line, symbolize_names: true)
      STDERR.puts "Received: #{req.inspect}"

      body = req[:body]
      case body[:type]
      when "init"
        @node_id = body[:node_id]
        STDERR.puts "Initialized node #{@node_id}"
        reply!(req, {type: "init_ok"})
      when "echo"
        STDERR.puts "Echoing #{body}"
        reply!(req, body.merge({type: "echo_ok"}))
      end
    end
  end

  def reply!(request, body)
    body.merge!(
      msg_id: generate_next_msg_id,
      in_reply_to: request[:body][:msg_id]
    )
    msg = {
      src: @node_id,
      dest: request[:src],
      body: body
    }
    # We'll make sure to flush stdout: otherwise our message could sit in the
    # stdout buffer indefinitely, and Maelstrom wouldn't receive it.
    # (Comment borrowed from Maelstrom)
    JSON.dump(msg, STDOUT)
    STDOUT << "\n"
    STDOUT.flush
  end

  private

  def generate_next_msg_id
    @next_msg_id += 1
  end
end

EchoServer.new.main!
